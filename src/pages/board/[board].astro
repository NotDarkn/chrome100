---
import type {
  cros_brand,
  cros_recovery_image_db,
  cros_target,
} from "chrome-versions";
import { getRecoveryURL } from "chrome-versions";
import { getBrands, getRecoveryImages, getTarget, getTargets } from "@lib/db";
import { getShims } from "@lib/shim";
import MainLayout from "@layouts/MainLayout.astro";
import type { GetStaticPaths } from "astro";

export const getStaticPaths: GetStaticPaths = () => {
  const targets = getTargets.all() as cros_target[];

  return targets.map((target) => ({
    params: { board: target.board },
  }));
};

const board = Astro.params.board.toString();

let target: cros_target | undefined;
let images: cros_recovery_image_db[];
let brands: cros_brand[];

if (board) {
  target = getTarget.get(board) as cros_target | undefined;

  if (target) {
    images = getRecoveryImages.all(board) as cros_recovery_image_db[];
    brands = getBrands.all(board) as cros_brand[];
  }
}

if (!target) {
  Astro.response.status = 404;
  Astro.response.statusText = "Not found";
}

const shims = getShims(board);
---

<MainLayout>
  {
    target ? (
      <>
        <h1>
          Chrome OS board <code>{board}</code>
        </h1>
        <h2>RMA Shim</h2>
        <p>
          {shims.length ? (
            shims.map((e) => (
              <>
                <a href={e.url}>Download ({e.mirror})</a>
                <br />
              </>
            ))
          ) : (
            <>
              No RMA shim was found for <code>{board}</code>.
              <br />
            </>
          )}
          Click <a href="/info#shim">here</a> for more information
        </p>
        <h2>Brands</h2>
        <ul>
          {brands.map((brand) => (
            <li>{brand.brand}</li>
          ))}
        </ul>
        <h2>Recovery Images</h2>
        <h3>Sort</h3>
        <select id="imageSortOrder">
          <option value="lastModified">Last Modified</option>
          <option value="chrome">Chrome Version</option>
          <option value="platform">Platform Version</option>
        </select>
        <label>
          <input type="checkbox" id="imageSortReverse" />
          Reverse
        </label>
        <h3>Boards</h3>
        {images.length ? (
          <>
            <table>
              <thead>
                <tr>
                  <th>Platform</th>
                  <th>Chrome</th>
                  <th>Modified</th>
                  <th />
                </tr>
              </thead>
              <tbody id="recoveryImages">
                {images.map((img) => (
                  <tr
                    data-modified={new Date(img.last_modified).getTime()}
                    data-chrome={img.chrome}
                    data-platform={img.platform}
                  >
                    <td>{img.platform}</td>
                    <td>{img.chrome}</td>
                    <td>{img.last_modified}</td>
                    <td>
                      <a href={getRecoveryURL(img)}>Download</a>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </>
        ) : (
          <p>
            No recovery images found. Either this board name has no images
            available or it has not been scraped yet.
          </p>
        )}
      </>
    ) : (
      <>Unknown board.</>
    )
  }
</MainLayout>
<script>
  import { parseChromeVersion, parsePlatformVersion } from "chrome-versions";

  const recoveryImages =
    document.querySelector<HTMLTableSectionElement>("#recoveryImages");

  // undefined if this is a 404 page
  if (recoveryImages) {
    // store image sort preferences in localStorage
    // sort clientside

    // by default, sort by last modified
    let imageSortOrder: SortOrder =
      "imageSortOrder" in localStorage
        ? (localStorage.imageSortOrder as SortOrder)
        : "chrome";

    const inputImageSortOrder =
      document.querySelector<HTMLInputElement>("#imageSortOrder");

    inputImageSortOrder.value = imageSortOrder;

    inputImageSortOrder.addEventListener("change", () => {
      imageSortOrder = inputImageSortOrder.value as SortOrder;
      localStorage.imageSortOrder = imageSortOrder;
      sortImages();
    });

    // by default, show the images in reverse order
    let imageSortReverse =
      "imageSortReverse" in localStorage
        ? localStorage.imageSortReverse === "1"
        : true;

    const inputImageSortReverse =
      document.querySelector<HTMLInputElement>("#imageSortReverse");

    inputImageSortReverse.checked = imageSortReverse;

    inputImageSortReverse.addEventListener("change", () => {
      imageSortReverse = inputImageSortReverse.checked;
      if (imageSortReverse) localStorage.imageSortReverse = "1";
      else delete localStorage.imageSortReverse;
      sortImages();
    });

    type SortOrder = "lastModified" | "chrome" | "platform";

    const sortVersions = (a: number[], b: number[]) => {
      if (a.length !== b.length) throw new Error("array length mismatch");
      for (let i = 0; i < a.length; i++)
        if (a !== b) return a[i] > b[i] ? 1 : -1;
      return b.length - a.length;
    };

    const sortImages = () => {
      const children = [...recoveryImages.children];

      children.sort((a, b) => {
        switch (imageSortOrder) {
          case "chrome": {
            const av = parseChromeVersion(a.getAttribute("data-chrome"));
            const bv = parseChromeVersion(b.getAttribute("data-chrome"));
            return sortVersions(av, bv);
          }
          case "platform": {
            const av = parsePlatformVersion(a.getAttribute("data-platform"));
            const bv = parsePlatformVersion(b.getAttribute("data-platform"));
            return sortVersions(av, bv);
          }
          case "lastModified":
            return (
              Number(a.getAttribute("data-modified")) -
              Number(b.getAttribute("data-modified"))
            );
        }
      });

      if (imageSortReverse) children.reverse();

      for (const child of children) recoveryImages.append(child);
    };

    sortImages();
  }
</script>
